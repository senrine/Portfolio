import {
  useTheme
} from "./chunk-KYDE6FLK.js";
import {
  menuContentTheme,
  menuItemTheme,
  menuTheme,
  menuTriggerTheme
} from "./chunk-WZOFG7WK.js";

// src/components/menu.tsx
import * as React from "react";
import {
  FloatingPortal,
  FloatingFocusManager,
  FloatingNode,
  FloatingList,
  FloatingTree
} from "@floating-ui/react";
import {
  useFloating,
  useClick,
  useDismiss,
  useRole,
  useHover,
  useInteractions,
  useMergeRefs,
  useFloatingTree,
  useFloatingNodeId,
  useFloatingParentNodeId,
  useListItem,
  useListNavigation
} from "@floating-ui/react";
import {
  autoUpdate,
  flip as fuiFlip,
  offset as fuiOffset,
  shift,
  safePolygon
} from "@floating-ui/react";
import { twMerge } from "tailwind-merge";
import Ripple from "material-ripple-effects";
import { jsx } from "react/jsx-runtime";
var MenuContext = React.createContext({
  open: false,
  setOpen: () => {
  }
});
function MenuCore({
  open: controlledOpen,
  onOpenChange: setControlledOpen,
  placement,
  offset,
  children
}) {
  const contextTheme = useTheme();
  const theme = contextTheme?.menu ?? menuTheme;
  const defaultProps = theme?.defaultProps;
  const [uncontrolledOpen, setUncontrolledOpen] = React.useState(false);
  const [activeIndex, setActiveIndex] = React.useState(null);
  const elementsRef = React.useRef([]);
  const labelsRef = React.useRef([]);
  const tree = useFloatingTree();
  const nodeId = useFloatingNodeId();
  const parentId = useFloatingParentNodeId();
  const item = useListItem();
  const isNested = parentId != null;
  const open = controlledOpen ?? uncontrolledOpen;
  const setOpen = setControlledOpen ?? setUncontrolledOpen;
  placement ??= isNested ? "right-start" : defaultProps?.placement ?? "bottom";
  offset ??= isNested ? 8 : defaultProps?.offset ?? 5;
  const { floatingStyles, refs, context } = useFloating({
    nodeId,
    placement,
    open,
    onOpenChange: setOpen,
    whileElementsMounted: autoUpdate,
    middleware: [fuiOffset(offset), fuiFlip(), shift({ padding: 5 })]
  });
  const hover = useHover(context, {
    enabled: isNested,
    delay: { open: 75 },
    handleClose: safePolygon({ blockPointerEvents: true })
  });
  const click = useClick(context, {
    event: "mousedown",
    toggle: !isNested,
    ignoreMouse: isNested
  });
  const role = useRole(context, { role: "menu" });
  const dismiss = useDismiss(context, { bubbles: true });
  const listNavigation = useListNavigation(context, {
    listRef: elementsRef,
    activeIndex,
    nested: isNested,
    onNavigate: setActiveIndex
  });
  const { getReferenceProps, getFloatingProps, getItemProps } = useInteractions(
    [hover, click, role, dismiss, listNavigation]
  );
  const contextValue = React.useMemo(
    () => ({
      open,
      setOpen,
      getReferenceProps,
      getFloatingProps,
      getItemProps,
      floatingStyles,
      refs,
      context,
      item,
      isNested,
      activeIndex,
      elementsRef,
      labelsRef
    }),
    [
      open,
      setOpen,
      getReferenceProps,
      getFloatingProps,
      getItemProps,
      floatingStyles,
      refs,
      context,
      item,
      isNested,
      activeIndex,
      elementsRef,
      labelsRef
    ]
  );
  React.useEffect(() => {
    if (!tree)
      return;
    function handleTreeClick() {
      setOpen(false);
    }
    function onSubMenuOpen(event) {
      if (event.nodeId !== nodeId && event.parentId === parentId) {
        setOpen(false);
      }
    }
    tree.events.on("click", handleTreeClick);
    tree.events.on("menuopen", onSubMenuOpen);
    return () => {
      tree.events.off("click", handleTreeClick);
      tree.events.off("menuopen", onSubMenuOpen);
    };
  }, [tree, nodeId, parentId]);
  React.useEffect(() => {
    if (open && tree) {
      tree.events.emit("menuopen", { parentId, nodeId });
    }
  }, [tree, open, nodeId, parentId]);
  return /* @__PURE__ */ jsx(FloatingNode, { id: nodeId, children: /* @__PURE__ */ jsx(MenuContext.Provider, { value: contextValue, children }) });
}
function MenuRoot(props) {
  const parentId = useFloatingParentNodeId();
  return parentId === null ? /* @__PURE__ */ jsx(FloatingTree, { children: /* @__PURE__ */ jsx(MenuCore, { ...props }) }) : /* @__PURE__ */ jsx(MenuCore, { ...props });
}
MenuRoot.displayName = "MaterialTailwind.Menu";
var MenuTrigger = React.forwardRef(
  ({ as, className, children, ...rest }, ref) => {
    const Element = as || "button";
    const contextTheme = useTheme();
    const theme = contextTheme?.menuTrigger ?? menuTriggerTheme;
    const {
      refs,
      item,
      activeIndex,
      isNested,
      getReferenceProps,
      getItemProps,
      open
    } = React.useContext(MenuContext);
    const styles = twMerge(theme.baseStyle, className);
    const elementRef = useMergeRefs([refs?.setReference, item?.ref, ref]);
    return /* @__PURE__ */ jsx(
      Element,
      {
        ...rest,
        ref: elementRef,
        "data-open": open,
        "data-nested": isNested,
        tabIndex: !isNested ? void 0 : activeIndex === item?.index ? 0 : -1,
        role: isNested ? "menuitem" : void 0,
        className: styles,
        ...getReferenceProps && getItemProps && getReferenceProps(getItemProps()),
        children
      }
    );
  }
);
MenuTrigger.displayName = "MaterialTailwind.MenuTrigger";
var MenuContent = React.forwardRef(
  ({
    as,
    className,
    children,
    disabled,
    initialFocus,
    returnFocus,
    guards,
    modal,
    visuallyHiddenDismiss,
    closeOnFocusOut,
    order,
    ...rest
  }, ref) => {
    const Element = as || "div";
    const contextTheme = useTheme();
    const theme = contextTheme?.menuContent ?? menuContentTheme;
    const defaultProps = theme.defaultProps;
    const {
      elementsRef,
      labelsRef,
      context,
      refs,
      getFloatingProps,
      open,
      floatingStyles,
      isNested
    } = React.useContext(MenuContext);
    disabled ??= defaultProps?.disabled ?? false;
    initialFocus ??= defaultProps?.initialFocus ?? 0;
    returnFocus ??= defaultProps?.returnFocus ?? true;
    guards ??= defaultProps?.guards ?? true;
    modal ??= defaultProps?.modal ?? false;
    visuallyHiddenDismiss ??= defaultProps?.visuallyHiddenDismiss ?? true;
    closeOnFocusOut ??= defaultProps?.closeOnFocusOut ?? true;
    order ??= defaultProps?.order ?? ["content"];
    const styles = twMerge(theme.baseStyle, className);
    const elementRef = useMergeRefs([refs?.setFloating, ref]);
    return /* @__PURE__ */ jsx(
      FloatingList,
      {
        elementsRef,
        labelsRef,
        children: open && /* @__PURE__ */ jsx(FloatingPortal, { children: /* @__PURE__ */ jsx(
          FloatingFocusManager,
          {
            order,
            modal,
            guards,
            disabled,
            initialFocus: isNested ? -1 : initialFocus,
            returnFocus: isNested ? false : returnFocus,
            closeOnFocusOut,
            visuallyHiddenDismiss,
            context,
            children: /* @__PURE__ */ jsx(
              Element,
              {
                ...rest,
                ref: elementRef,
                "data-open": open,
                style: { ...floatingStyles, ...rest?.style },
                className: styles,
                ...getFloatingProps && getFloatingProps(),
                children
              }
            )
          }
        ) })
      }
    );
  }
);
MenuContent.displayName = "MaterialTailwind.MenuContent";
var MenuItem = React.forwardRef(
  ({ as, className, ripple, disabled, closeOnClick, children, ...rest }, ref) => {
    const Element = as || "button";
    const contextTheme = useTheme();
    const theme = contextTheme?.menuItem ?? menuItemTheme;
    const defaultProps = theme.defaultProps;
    const { activeIndex, getItemProps } = React.useContext(MenuContext);
    ripple ??= defaultProps?.ripple ?? true;
    closeOnClick ??= defaultProps?.closeOnClick ?? true;
    const rippleEffect = ripple !== void 0 && new Ripple();
    const item = useListItem({
      label: disabled ? null : children
    });
    const tree = useFloatingTree();
    const isActive = item.index === activeIndex;
    const elementRef = useMergeRefs([item.ref, ref]);
    const styles = twMerge(theme.baseStyle, className);
    return /* @__PURE__ */ jsx(
      Element,
      {
        ...rest,
        ref: elementRef,
        role: "menuitem",
        "aria-disabled": disabled,
        tabIndex: isActive ? 0 : -1,
        className: styles,
        ...getItemProps && getItemProps({
          onClick(event) {
            rest.onClick?.(event);
            if (closeOnClick) {
              tree?.events.emit("click");
            }
            if (ripple) {
              rippleEffect.create(event, "dark");
            }
          }
        }),
        children
      }
    );
  }
);
var Menu = Object.assign(MenuRoot, {
  Trigger: MenuTrigger,
  Content: MenuContent,
  Item: MenuItem
});
var menu_default = Menu;

export {
  MenuContext,
  MenuRoot,
  MenuTrigger,
  MenuContent,
  MenuItem,
  Menu,
  menu_default
};
