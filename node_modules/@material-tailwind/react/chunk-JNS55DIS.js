import {
  useTheme
} from "./chunk-KYDE6FLK.js";
import {
  tooltipArrowTheme,
  tooltipContentTheme,
  tooltipTheme,
  tooltipTriggerTheme
} from "./chunk-CZOICNI5.js";

// src/components/tooltip.tsx
import * as React from "react";
import { FloatingPortal } from "@floating-ui/react";
import {
  useFloating,
  useHover,
  useFocus,
  useDismiss,
  useRole,
  useInteractions,
  useMergeRefs
} from "@floating-ui/react";
import {
  autoUpdate,
  flip as fuiFlip,
  offset as fuiOffset,
  shift,
  arrow,
  safePolygon
} from "@floating-ui/react";
import { twMerge } from "tailwind-merge";
import { jsx } from "react/jsx-runtime";
var TooltipContext = React.createContext({
  open: false,
  setOpen: () => {
  }
});
function TooltipRoot({
  open: controlledOpen,
  onOpenChange: setControlledOpen,
  placement,
  offset,
  interactive,
  children
}) {
  const arrowRef = React.useRef(null);
  const contextTheme = useTheme();
  const theme = contextTheme?.tooltip ?? tooltipTheme;
  const defaultProps = theme?.defaultProps;
  const [uncontrolledOpen, setUncontrolledOpen] = React.useState(false);
  const open = controlledOpen ?? uncontrolledOpen;
  const setOpen = setControlledOpen ?? setUncontrolledOpen;
  placement ??= defaultProps?.placement ?? "top";
  offset ??= defaultProps?.offset ?? 8;
  interactive ??= defaultProps?.interactive ?? false;
  const data = useFloating({
    placement,
    open,
    onOpenChange: setOpen,
    whileElementsMounted: autoUpdate,
    middleware: [
      fuiOffset(offset),
      fuiFlip({
        crossAxis: placement.includes("-"),
        fallbackAxisSideDirection: "end",
        padding: 5
      }),
      shift({ padding: 5 }),
      arrow({
        element: arrowRef,
        padding: 5
      })
    ]
  });
  const { context } = data;
  const hover = useHover(context, {
    move: true,
    enabled: controlledOpen == null,
    handleClose: interactive ? safePolygon() : null
  });
  const focus = useFocus(context, {
    enabled: controlledOpen == null
  });
  const dismiss = useDismiss(context);
  const role = useRole(context, { role: "tooltip" });
  const interactions = useInteractions([hover, focus, dismiss, role]);
  const contextValue = React.useMemo(
    () => ({
      open,
      setOpen,
      arrowRef,
      ...interactions,
      ...data
    }),
    [open, setOpen, arrowRef, interactions, data]
  );
  return /* @__PURE__ */ jsx(TooltipContext.Provider, { value: contextValue, children });
}
TooltipRoot.displayName = "MaterialTailwind.Tooltip";
var TooltipTrigger = React.forwardRef(({ as, className, children, ...rest }, ref) => {
  const Element = as || "button";
  const contextTheme = useTheme();
  const theme = contextTheme?.tooltipTrigger ?? tooltipTriggerTheme;
  const { refs, getReferenceProps, open } = React.useContext(TooltipContext);
  const styles = twMerge(theme.baseStyle, className);
  const elementRef = useMergeRefs([refs?.setReference, ref]);
  return /* @__PURE__ */ jsx(
    Element,
    {
      ...rest,
      ref: elementRef,
      "data-open": open,
      className: styles,
      ...getReferenceProps && getReferenceProps(),
      children
    }
  );
});
TooltipTrigger.displayName = "MaterialTailwind.TooltipTrigger";
var TooltipContent = React.forwardRef(({ as, className, children, ...rest }, ref) => {
  const Element = as || "div";
  const contextTheme = useTheme();
  const theme = contextTheme?.tooltipContent ?? tooltipContentTheme;
  const { refs, getFloatingProps, open, floatingStyles } = React.useContext(TooltipContext);
  const styles = twMerge(theme.baseStyle, className);
  const elementRef = useMergeRefs([refs?.setFloating, ref]);
  return open ? /* @__PURE__ */ jsx(FloatingPortal, { children: /* @__PURE__ */ jsx(
    Element,
    {
      ...rest,
      ref: elementRef,
      "data-open": open,
      style: { ...floatingStyles, ...rest?.style },
      className: styles,
      ...getFloatingProps && getFloatingProps(),
      children
    }
  ) }) : null;
});
TooltipContent.displayName = "MaterialTailwind.TooltipContent";
var TooltipArrow = React.forwardRef(
  ({ as, className, ...rest }, ref) => {
    const Element = as || "span";
    const contextTheme = useTheme();
    const theme = contextTheme?.tooltipArrow ?? tooltipArrowTheme;
    const innerRef = React.useRef(null);
    const { placement, arrowRef, middlewareData } = React.useContext(TooltipContext);
    const elementRef = useMergeRefs([arrowRef, innerRef, ref]);
    const staticSide = {
      top: "bottom",
      right: "left",
      bottom: "top",
      left: "right"
    }[placement ? placement.split("-")[0] : ""];
    const styles = twMerge(theme.baseStyle, className);
    return /* @__PURE__ */ jsx(
      Element,
      {
        ...rest,
        ref: elementRef,
        style: {
          position: "absolute",
          left: middlewareData?.arrow?.x,
          top: middlewareData?.arrow?.y,
          [staticSide]: `${-innerRef?.current?.clientHeight / 2 - 1}px`,
          ...rest?.style
        },
        "data-placement": placement,
        className: styles
      }
    );
  }
);
var Tooltip = Object.assign(TooltipRoot, {
  Trigger: TooltipTrigger,
  Content: TooltipContent,
  Arrow: TooltipArrow
});
var tooltip_default = Tooltip;

export {
  TooltipContext,
  TooltipRoot,
  TooltipTrigger,
  TooltipContent,
  TooltipArrow,
  Tooltip,
  tooltip_default
};
