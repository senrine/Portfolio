import {
  useTheme
} from "./chunk-KYDE6FLK.js";
import {
  drawerDismissTriggerTheme,
  drawerOverlayTheme,
  drawerPanelTheme,
  drawerTriggerTheme
} from "./chunk-KLVY2RS4.js";

// src/components/drawer.tsx
import * as React from "react";
import {
  FloatingPortal,
  FloatingOverlay,
  FloatingFocusManager
} from "@floating-ui/react";
import {
  useFloating,
  useClick,
  useRole,
  useDismiss,
  useInteractions,
  useMergeRefs
} from "@floating-ui/react";
import { twMerge } from "tailwind-merge";
import { jsx } from "react/jsx-runtime";
var DrawerContext = React.createContext(
  {}
);
function DrawerRoot({
  open: controlledOpen,
  onOpenChange: setControlledOpen,
  children
}) {
  const [uncontrolledOpen, setUncontrolledOpen] = React.useState(false);
  const open = controlledOpen ?? uncontrolledOpen;
  const setOpen = setControlledOpen ?? setUncontrolledOpen;
  const data = useFloating({
    open,
    onOpenChange: setOpen
  });
  const { context } = data;
  const click = useClick(context, {
    enabled: controlledOpen == null
  });
  const dismiss = useDismiss(context, { outsidePressEvent: "mousedown" });
  const role = useRole(context);
  const interactions = useInteractions([click, dismiss, role]);
  const contextValue = React.useMemo(
    () => ({
      open,
      setOpen,
      ...interactions,
      ...data
    }),
    [open, setOpen, interactions, data]
  );
  return /* @__PURE__ */ jsx(DrawerContext.Provider, { value: contextValue, children });
}
DrawerRoot.displayName = "MaterialTailwind.Drawer";
var DrawerTrigger = React.forwardRef(
  ({ as, className, children, ...rest }, ref) => {
    const Element = as || "button";
    const contextTheme = useTheme();
    const theme = contextTheme?.drawerTrigger ?? drawerTriggerTheme;
    const { refs, getReferenceProps, open } = React.useContext(DrawerContext);
    const styles = twMerge(theme.baseStyle, className);
    const elementRef = useMergeRefs([refs?.setReference, ref]);
    return /* @__PURE__ */ jsx(
      Element,
      {
        ...rest,
        ref: elementRef,
        "data-open": open,
        className: styles,
        ...getReferenceProps && getReferenceProps(),
        children
      }
    );
  }
);
DrawerTrigger.displayName = "MaterialTailwind.DrawerTrigger";
var DrawerOverlay = React.forwardRef(({ className, lockScroll, children, ...rest }, ref) => {
  const contextTheme = useTheme();
  const theme = contextTheme?.drawerOverlay ?? drawerOverlayTheme;
  const defaultProps = theme?.defaultProps;
  const { open } = React.useContext(DrawerContext);
  lockScroll ??= defaultProps?.lockScroll ?? true;
  const styles = twMerge(theme.baseStyle, className);
  return open ? /* @__PURE__ */ jsx(FloatingPortal, { children: /* @__PURE__ */ jsx(
    FloatingOverlay,
    {
      ...rest,
      ref,
      "data-open": open,
      className: styles,
      lockScroll,
      children
    }
  ) }) : null;
});
DrawerOverlay.displayName = "MaterialTailwind.DrawerOverlay";
var DrawerPanel = React.forwardRef(
  ({
    as,
    className,
    children,
    placement,
    disabled,
    initialFocus,
    returnFocus,
    guards,
    modal,
    visuallyHiddenDismiss,
    closeOnFocusOut,
    order,
    ...rest
  }, ref) => {
    const Element = as || "div";
    const contextTheme = useTheme();
    const theme = contextTheme?.drawerPanel ?? drawerPanelTheme;
    const defaultProps = theme.defaultProps;
    const { context, refs, getFloatingProps, open } = React.useContext(DrawerContext);
    placement ??= defaultProps?.placement ?? "right";
    disabled ??= defaultProps?.disabled ?? false;
    initialFocus ??= defaultProps?.initialFocus ?? 0;
    returnFocus ??= defaultProps?.returnFocus ?? true;
    guards ??= defaultProps?.guards ?? true;
    modal ??= defaultProps?.modal ?? false;
    visuallyHiddenDismiss ??= defaultProps?.visuallyHiddenDismiss ?? true;
    closeOnFocusOut ??= defaultProps?.closeOnFocusOut ?? true;
    order ??= defaultProps?.order ?? ["content"];
    const styles = twMerge(theme.baseStyle, className);
    const elementRef = useMergeRefs([refs?.setFloating, ref]);
    return open ? /* @__PURE__ */ jsx(
      FloatingFocusManager,
      {
        order,
        modal,
        guards,
        disabled,
        returnFocus,
        initialFocus,
        closeOnFocusOut,
        visuallyHiddenDismiss,
        context,
        children: /* @__PURE__ */ jsx(
          Element,
          {
            ...rest,
            ref: elementRef,
            className: styles,
            "data-open": open,
            "data-placement": placement,
            ...getFloatingProps && getFloatingProps(),
            children
          }
        )
      }
    ) : null;
  }
);
DrawerPanel.displayName = "MaterialTailwind.DrawerPanel";
var DrawerDismissTrigger = React.forwardRef(({ as, className, children, ...rest }, ref) => {
  const Element = as || "button";
  const contextTheme = useTheme();
  const theme = contextTheme?.drawerDismissTrigger ?? drawerDismissTriggerTheme;
  const { open, setOpen } = React.useContext(DrawerContext);
  const styles = twMerge(theme.baseStyle, className);
  return /* @__PURE__ */ jsx(
    Element,
    {
      ...rest,
      ref,
      "data-open": open,
      className: styles,
      onClick: (event) => {
        rest.onClick?.(event);
        if (setOpen) {
          setOpen(false);
        }
      },
      children
    }
  );
});
DrawerDismissTrigger.displayName = "MaterialTailwind.DrawerDismissTrigger";
var Drawer = Object.assign(DrawerRoot, {
  Trigger: DrawerTrigger,
  Overlay: DrawerOverlay,
  Panel: DrawerPanel,
  DismissTrigger: DrawerDismissTrigger
});
var drawer_default = Drawer;

export {
  DrawerRoot,
  DrawerTrigger,
  DrawerOverlay,
  DrawerPanel,
  DrawerDismissTrigger,
  Drawer,
  drawer_default
};
