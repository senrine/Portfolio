import {
  useTheme
} from "./chunk-KYDE6FLK.js";
import {
  timelineBodyTheme,
  timelineHeaderTheme,
  timelineIconTheme,
  timelineItemTheme,
  timelineSeparatorTheme,
  timelineTheme
} from "./chunk-BAFDZUY3.js";

// src/components/timeline.tsx
import * as React from "react";
import { twMerge } from "tailwind-merge";
import { useMergeRefs } from "@floating-ui/react";
import { jsx } from "react/jsx-runtime";
var TimelineContext = React.createContext({
  value: "",
  setValue: () => {
  },
  color: "primary",
  mode: "timeline",
  orientation: "horizontal"
});
var TimelineRoot = React.forwardRef(
  ({
    as,
    value,
    defaultValue,
    onChange,
    color,
    mode,
    orientation,
    className,
    children,
    ...props
  }, ref) => {
    const Element = as || "div";
    const contextTheme = useTheme();
    const theme = contextTheme?.timeline ?? timelineTheme;
    const defaultProps = theme?.defaultProps;
    const innerRef = React.useRef(null);
    const [innerValue, setInnerValue] = React.useState(defaultValue || "");
    value ??= innerValue;
    onChange ??= setInnerValue;
    mode ??= defaultProps?.mode ?? "timeline";
    color ??= defaultProps?.color ?? "primary";
    orientation ??= defaultProps?.orientation ?? "horizontal";
    React.useEffect(() => {
      const parentEl = innerRef?.current;
      if (parentEl && !value) {
        const children2 = Array.from(parentEl.children);
        const firstChild = children2[0];
        onChange?.(firstChild.dataset.value);
      }
    }, []);
    React.useEffect(() => {
      if (mode === "stepper") {
        const parentEl = innerRef?.current;
        if (parentEl) {
          const children2 = Array.from(parentEl.children);
          const currentEl = children2.find(
            (child) => child.dataset.value == value
          );
          const currentElIndex = children2.findIndex(
            (child) => child.dataset.value == value
          );
          const activeElIndex = children2.findIndex(
            (child) => child.dataset.active === "true"
          );
          const completedSteps = children2.filter(
            (_, index) => index < activeElIndex
          );
          const incompletedSteps = children2.filter(
            (_, index) => index > activeElIndex
          );
          completedSteps.forEach((step) => {
            step.dataset.completed = "true";
          });
          incompletedSteps.forEach((step) => {
            step.dataset.completed = "false";
          });
          if (currentElIndex === activeElIndex && currentEl) {
            currentEl.dataset.completed = "false";
          }
        }
      }
    }, [value]);
    const contextValue = React.useMemo(
      () => ({
        value,
        setValue: onChange,
        orientation,
        color,
        mode,
        parentRef: innerRef
      }),
      [value, onChange, orientation, color, mode]
    );
    const styles = twMerge(theme.baseStyle, className);
    const mergedRef = useMergeRefs([ref, innerRef]);
    return /* @__PURE__ */ jsx(
      Element,
      {
        ...props,
        ref: mergedRef,
        className: styles,
        "data-orientation": orientation,
        children: /* @__PURE__ */ jsx(TimelineContext.Provider, { value: contextValue, children })
      }
    );
  }
);
TimelineRoot.displayName = "MaterialTailwind.Timeline";
var TimelineItem = React.forwardRef(
  ({ as, value, className, disabled, children, ...props }, ref) => {
    const Element = as || "div";
    const contextTheme = useTheme();
    const theme = contextTheme?.timelineItem ?? timelineItemTheme;
    const {
      mode,
      setValue,
      orientation,
      value: contextValue
    } = React.useContext(TimelineContext);
    const innerRef = React.useRef(null);
    value ??= React.useId();
    const isActive = contextValue == value || mode === "timeline";
    function onClick(event) {
      props?.onClick?.(event);
      if (mode === "stepper") {
        setValue?.(value);
      }
    }
    const styles = twMerge(theme.baseStyle, className);
    const mergedRef = useMergeRefs([ref, innerRef]);
    return /* @__PURE__ */ jsx(
      Element,
      {
        ...props,
        ref: mergedRef,
        onClick,
        "data-value": value,
        "data-active": isActive,
        "data-completed": isActive,
        "data-orientation": orientation,
        "aria-disabled": disabled,
        className: styles,
        children
      }
    );
  }
);
TimelineItem.displayName = "MaterialTailwind.TimelineItem";
var TimelineHeader = React.forwardRef(({ as, className, children, ...props }, ref) => {
  const Element = as || "div";
  const contextTheme = useTheme();
  const theme = contextTheme?.timelineHeader ?? timelineHeaderTheme;
  const styles = twMerge(theme.baseStyle, className);
  return /* @__PURE__ */ jsx(Element, { ...props, ref, className: styles, children });
});
TimelineHeader.displayName = "MaterialTailwind.TimelineHeader";
var TimelineIcon = React.forwardRef(
  ({ as, className, children, ...props }, ref) => {
    const Element = as || "span";
    const contextTheme = useTheme();
    const theme = contextTheme?.timelineIcon ?? timelineIconTheme;
    const { color } = React.useContext(TimelineContext);
    const styles = twMerge(theme.baseStyle, theme.color[color], className);
    return /* @__PURE__ */ jsx(Element, { ...props, ref, className: styles, children });
  }
);
TimelineIcon.displayName = "MaterialTailwind.TimelineIcon";
var TimelineSeparator = React.forwardRef(({ as, className, children, ...props }, ref) => {
  const Element = as || "div";
  const contextTheme = useTheme();
  const theme = contextTheme?.timelineSeparator ?? timelineSeparatorTheme;
  const { orientation, color } = React.useContext(TimelineContext);
  const styles = twMerge(theme.baseStyle, theme.color[color], className);
  return /* @__PURE__ */ jsx(
    Element,
    {
      ...props,
      ref,
      "data-orientation": orientation,
      className: styles,
      children
    }
  );
});
TimelineSeparator.displayName = "MaterialTailwind.TimelineSeparator";
var TimelineBody = React.forwardRef(
  ({ as, className, children, ...props }, ref) => {
    const Element = as || "div";
    const contextTheme = useTheme();
    const theme = contextTheme?.timelineBody ?? timelineBodyTheme;
    const { orientation } = React.useContext(TimelineContext);
    const styles = twMerge(theme.baseStyle, className);
    return /* @__PURE__ */ jsx(
      Element,
      {
        ...props,
        ref,
        className: styles,
        "data-orientation": orientation,
        children
      }
    );
  }
);
TimelineBody.displayName = "MaterialTailwind.TimelineBody";
var Timeline = Object.assign(TimelineRoot, {
  Item: TimelineItem,
  Icon: TimelineIcon,
  Body: TimelineBody,
  Header: TimelineHeader,
  Separator: TimelineSeparator
});

export {
  TimelineContext,
  TimelineRoot,
  TimelineItem,
  TimelineHeader,
  TimelineIcon,
  TimelineSeparator,
  TimelineBody,
  Timeline
};
